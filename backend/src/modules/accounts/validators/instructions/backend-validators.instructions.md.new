---
applyTo: 'backend/src/modules/accounts/validators/*.ts'
---

# Validators Folder: `backend/src/modules/accounts/validators`

## ğŸ—ï¸ MANDATORY BACKEND ARCHITECTURE - VALIDATORS LAYER

Validators are **Layer 3** in the mandatory 7-layer backend architecture:

**Route â†’ Middleware â†’ ğŸ¯ VALIDATORS â†’ Controller â†’ Services â†’ Utils â†’ Types**

### âœ… Validators Responsibilities (Layer 3)

Validators contain **schemas to validate incoming request data**:

- **Data format validation** - ensure proper data types and structure
- **Required field checks** - verify all mandatory fields are present
- **Value constraints** - enforce min/max, patterns, enums, etc.
- **Input sanitization** - clean and normalize data before processing
- **Schema definitions** - provide reusable validation schemas

### âŒ What Validators Should NOT Do

- **NO business logic** - pure validation only
- **NO database access** - no Prisma or external calls
- **NO side effects** - stateless validation only
- **NO authentication** - middleware handles auth
- **NO response handling** - controllers format responses

### ğŸ”„ Validator Pattern Using Zod

```typescript
import { z } from 'zod';

// âœ… Input validation schema
export const userUpdateSchema = z.object({
  firstName: z.string()
    .min(1, 'First name is required')
    .max(50, 'First name too long'),
  lastName: z.string()
    .min(1, 'Last name is required')
    .max(50, 'Last name too long'),
  email: z.string()
    .email('Invalid email format'),
  bio: z.string()
    .max(500, 'Bio too long')
    .optional(),
});

export type UserUpdateInput = z.infer<typeof userUpdateSchema>;

// âœ… Validation middleware factory
export const validateUserUpdate = (req: Request, res: Response, next: NextFunction) => {
  try {
    userUpdateSchema.parse(req.body);
    next();
  } catch (error) {
    if (error instanceof z.ZodError) {
      return res.status(400).json({
        error: 'Validation failed',
        details: error.errors
      });
    }
    next(error);
  }
};
```

### ğŸ“Œ OAuth-Only Authentication Consideration

Since this platform uses **OAuth 2.0 exclusively**:

- **NO password validation** - OAuth providers handle credentials
- **NO email/password schemas** - not applicable for OAuth flow
- **Focus on OAuth payloads** - validate OAuth callback data, tokens, provider metadata

### ğŸ”„ OAuth Validator Example

```typescript
export const oauthCallbackSchema = z.object({
  code: z.string().min(1, 'Authorization code required'),
  state: z.string().min(1, 'State parameter required'),
  provider: z.enum(['google', 'azure'], {
    errorMap: () => ({ message: 'Invalid OAuth provider' })
  })
});

export const oauthUserSchema = z.object({
  id: z.string(),
  email: z.string().email(),
  firstName: z.string().min(1),
  lastName: z.string().min(1),
  avatar: z.string().url().optional(),
  provider: z.enum(['google', 'azure'])
});
```

### ğŸ“ Validator Structure

Domain-specific validators for accounts module:

- **`auth.validator.ts`** - OAuth callback and authentication data validation
- **`user.validator.ts`** - User profile and account data validation
- **`kyc.validator.ts`** - KYC form submission and verification data validation

### âœ… Zod-First Approach

All validators **MUST use Zod** as the project-wide standard:

- **Type inference** - generate TypeScript types from schemas
- **Structured errors** - consistent error format across validators
- **Refinements** - custom validation logic for complex rules
- **Transforms** - data normalization and sanitization

### âœ… Architecture Compliance Rules

1. **Zod Only**: All validation must use Zod schema library
2. **No Business Logic**: Pure data validation only
3. **No Database Access**: Validators are stateless and synchronous
4. **Type Generation**: Use z.infer for TypeScript type generation
5. **Error Consistency**: Provide structured validation error responses

### ğŸ§ª Validation Best Practices

- **Fail Fast**: Validate at the edge before processing
- **Clear Messages**: Provide helpful error messages for users
- **Domain Separation**: Keep auth/user/kyc validators separate
- **Reusable Schemas**: Create composable validation building blocks
- **Security First**: Sanitize inputs to prevent injection attacks
