/** * Project Module Validators * Comprehensive Zod validation schemas for the Projects module *  * Architecture Layer: Validators (Layer 2) * Purpose: Input validation, sanitization, and business rule enforcement */import { z } from 'zod';import { PropertyStatus } from '@prisma/client';import { PROJECT_VALIDATION_RULES } from '../types/project.types';// ==========================================// PRIMITIVE VALIDATION SCHEMAS// ==========================================/** * Title validation with business rules */const titleSchema = z  .string()  .min(PROJECT_VALIDATION_RULES.title.minLength, `Title must be at least ${PROJECT_VALIDATION_RULES.title.minLength} characters`)  .max(PROJECT_VALIDATION_RULES.title.maxLength, `Title must not exceed ${PROJECT_VALIDATION_RULES.title.maxLength} characters`)  .trim()  .refine(    (val) => val.length > 0,    { message: 'Title cannot be empty after trimming' }  );/** * Description validation with enhanced rules */const descriptionSchema = z  .string()  .min(PROJECT_VALIDATION_RULES.description.minLength, `Description must be at least ${PROJECT_VALIDATION_RULES.description.minLength} characters`)  .max(PROJECT_VALIDATION_RULES.description.maxLength, `Description must not exceed ${PROJECT_VALIDATION_RULES.description.maxLength} characters`)  .trim()  .refine(    (val) => val.split(/\s+/).length >= 10,    { message: 'Description must contain at least 10 words' }  );/** * Token symbol validation with format enforcement */const tokenSymbolSchema = z  .string()  .min(PROJECT_VALIDATION_RULES.tokenSymbol.minLength)  .max(PROJECT_VALIDATION_RULES.tokenSymbol.maxLength)  .regex(PROJECT_VALIDATION_RULES.tokenSymbol.pattern, 'Token symbol must contain only uppercase letters and numbers')  .trim()  .transform((val) => val.toUpperCase());/** * Financial amount validation with precision handling */const financialAmountSchema = (fieldName: string, min: number, max: number) =>  z    .number()    .min(min, `${fieldName} must be at least ${min}`)    .max(max, `${fieldName} must not exceed ${max}`)    .positive(`${fieldName} must be positive`)    .refine(      (val) => Number.isFinite(val) && val === Math.round(val * 100) / 100,      { message: `${fieldName} can have at most 2 decimal places` }    );/** * Percentage validation (0-100) */const percentageSchema = (fieldName: string, min = 0, max = 100) =>  z    .number()    .min(min, `${fieldName} must be at least ${min}%`)    .max(max, `${fieldName} must not exceed ${max}%`)    .refine(      (val) => Number.isFinite(val) && val === Math.round(val * 100) / 100,      { message: `${fieldName} can have at most 2 decimal places` }    );/** * Location validation schemas */const countrySchema = z  .string()  .min(2, 'Country must be at least 2 characters')  .max(50, 'Country must not exceed 50 characters')  .trim();const citySchema = z  .string()  .min(2, 'City must be at least 2 characters')  .max(50, 'City must not exceed 50 characters')  .trim();const addressSchema = z  .string()  .min(10, 'Address must be at least 10 characters')  .max(200, 'Address must not exceed 200 characters')  .trim();/** * Image URLs validation */const imageUrlsSchema = z  .array(    z.string().url('Invalid image URL format')      .refine(        (url) => /\.(jpg|jpeg|png|gif|webp)(\?.*)?$/i.test(url),        { message: 'Image URL must point to a valid image file' }      )  )  .max(10, 'Cannot have more than 10 images')  .optional()  .default([]);// ==========================================// CORE PROJECT VALIDATION SCHEMAS// ==========================================/** * Create Project Input Validation * Comprehensive validation for new project creation */export const CreateProjectSchema = z  .object({    title: titleSchema,    description: descriptionSchema,    country: countrySchema,    city: citySchema,    address: addressSchema,    tokenPrice: financialAmountSchema('Token price', PROJECT_VALIDATION_RULES.tokenPrice.min, PROJECT_VALIDATION_RULES.tokenPrice.max),    tokenSymbol: tokenSymbolSchema,    totalPrice: financialAmountSchema('Total price', PROJECT_VALIDATION_RULES.totalPrice.min, PROJECT_VALIDATION_RULES.totalPrice.max),    minInvestment: financialAmountSchema('Minimum investment', PROJECT_VALIDATION_RULES.minInvestment.min, PROJECT_VALIDATION_RULES.minInvestment.max),    tokensAvailablePercent: percentageSchema('Tokens available percent', PROJECT_VALIDATION_RULES.tokensAvailablePercent.min, PROJECT_VALIDATION_RULES.tokensAvailablePercent.max),    apr: percentageSchema('APR', PROJECT_VALIDATION_RULES.apr.min, PROJECT_VALIDATION_RULES.apr.max),    irr: percentageSchema('IRR', PROJECT_VALIDATION_RULES.irr.min, PROJECT_VALIDATION_RULES.irr.max),    valueGrowth: percentageSchema('Value growth', 0, 1000), // Allow higher growth projections    imageUrls: imageUrlsSchema,    isFeatured: z.boolean().optional().default(false)  })  .refine(    (data) => data.minInvestment <= data.totalPrice,    {      message: 'Minimum investment cannot exceed total project price',      path: ['minInvestment']    }  )  .refine(    (data) => data.tokenPrice <= data.totalPrice,    {      message: 'Token price cannot exceed total project price',      path: ['tokenPrice']    }  )  .refine(    (data) => data.apr <= data.irr + 5, // Allow some flexibility    {      message: 'APR should typically not exceed IRR by more than 5%',      path: ['apr']    }  );/** * Update Project Input Validation * Partial validation for project updates */export const UpdateProjectSchema = CreateProjectSchema.partial().extend({  status: z.nativeEnum(PropertyStatus).optional()});/** * Project Status Update Schema */export const UpdateProjectStatusSchema = z.object({  status: z.nativeEnum(PropertyStatus),  reason: z.string().min(10, 'Status change reason must be at least 10 characters').optional()});// ==========================================// QUERY VALIDATION SCHEMAS// ==========================================/** * Project ID parameter validation */export const ProjectParamsSchema = z.object({  id: z.string().uuid('Invalid project ID format')});/** * Pagination validation with sensible defaults */export const ProjectPaginationSchema = z.object({  page: z    .string()    .optional()    .transform((val) => val ? parseInt(val, 10) : 1)    .pipe(z.number().min(1, 'Page must be at least 1').max(10000, 'Page cannot exceed 10000')),  limit: z    .string()    .optional()    .transform((val) => val ? parseInt(val, 10) : 10)    .pipe(z.number().min(1, 'Limit must be at least 1').max(100, 'Limit cannot exceed 100')),  sortBy: z    .enum(['createdAt', 'updatedAt', 'title', 'totalPrice', 'tokenPrice', 'apr', 'irr', 'status'])    .optional()    .default('createdAt'),  sortOrder: z    .enum(['asc', 'desc'])    .optional()    .default('desc')});/** * Project filters validation */export const ProjectFiltersSchema = z.object({  status: z    .string()    .optional()    .transform((val) => val ? val.split(',').map(s => s.trim() as PropertyStatus) : undefined)    .pipe(z.array(z.nativeEnum(PropertyStatus)).optional()),  country: z    .string()    .optional()    .transform((val) => val ? val.split(',').map(s => s.trim()) : undefined)    .pipe(z.array(z.string()).optional()),  city: z    .string()    .optional()    .transform((val) => val ? val.split(',').map(s => s.trim()) : undefined)    .pipe(z.array(z.string()).optional()),  clientId: z    .string()    .optional()    .transform((val) => val ? val.split(',').map(s => s.trim()) : undefined)    .pipe(z.array(z.string().uuid()).optional()),  search: z.string().min(2, 'Search term must be at least 2 characters').optional(),  isFeatured: z    .string()    .optional()    .transform((val) => val === 'true' ? true : val === 'false' ? false : undefined)    .pipe(z.boolean().optional()),  minTokenPrice: z    .string()    .optional()    .transform((val) => val ? parseFloat(val) : undefined)    .pipe(z.number().positive().optional()),  maxTokenPrice: z    .string()    .optional()    .transform((val) => val ? parseFloat(val) : undefined)    .pipe(z.number().positive().optional()),  minTotalPrice: z    .string()    .optional()    .transform((val) => val ? parseFloat(val) : undefined)    .pipe(z.number().positive().optional()),  maxTotalPrice: z    .string()    .optional()    .transform((val) => val ? parseFloat(val) : undefined)    .pipe(z.number().positive().optional()),  minApr: z    .string()    .optional()    .transform((val) => val ? parseFloat(val) : undefined)    .pipe(z.number().min(0).max(100).optional()),  maxApr: z    .string()    .optional()    .transform((val) => val ? parseFloat(val) : undefined)    .pipe(z.number().min(0).max(100).optional()),  minIrr: z    .string()    .optional()    .transform((val) => val ? parseFloat(val) : undefined)    .pipe(z.number().min(0).max(100).optional()),  maxIrr: z    .string()    .optional()    .transform((val) => val ? parseFloat(val) : undefined)    .pipe(z.number().min(0).max(100).optional())});/** * Search Projects Schema * Combines pagination and filtering */export const SearchProjectsSchema = ProjectPaginationSchema.merge(  z.object({    filters: ProjectFiltersSchema.optional()  }));// ==========================================// UTILITY FUNCTIONS// ==========================================/** * Validate project ownership */export const validateProjectOwnership = (projectClientId: string, userClientId?: string) => {  return projectClientId === userClientId;};/** * Validate status transition */export const validateStatusTransition = (from: PropertyStatus, to: PropertyStatus): boolean => {  const allowedTransitions: Record<PropertyStatus, PropertyStatus[]> = {    DRAFT: ['PENDING'],    PENDING: ['APPROVED', 'REJECTED'],    APPROVED: ['DRAFT', 'PENDING'], // Allow modifications    REJECTED: ['DRAFT', 'PENDING']  // Allow resubmission  };    return allowedTransitions[from]?.includes(to) ?? false;};// ==========================================// SCHEMA TYPES EXPORTS// ==========================================export type CreateProjectInput = z.infer<typeof CreateProjectSchema>;export type UpdateProjectInput = z.infer<typeof UpdateProjectSchema>;export type ProjectParams = z.infer<typeof ProjectParamsSchema>;export type ProjectPagination = z.infer<typeof ProjectPaginationSchema>;export type ProjectFilters = z.infer<typeof ProjectFiltersSchema>;export type SearchProjects = z.infer<typeof SearchProjectsSchema>;