generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Blockchain {
  SEPOLIA
  POLYGON
  MAINNET
}

enum PaymentMethod {
  FIAT
  CRYPTO
}

enum InvestmentStatus {
  PENDING
  CONFIRMED
  FAILED
  CANCELLED
  REFUNDED
}

enum ProjectStage {
  PLANNING
  UNDER_CONSTRUCTION
  COMPLETED
}

enum PropertyCategory {
  RESIDENTIAL
  COMMERCIAL
  INDUSTRIAL
  HOSPITALITY
  MIXED_USE
  OTHER
}

enum UserRole {
  INVESTOR
  CLIENT
  ADMIN
}

enum AuthProvider {
  GOOGLE
  AZURE
}

enum ClientStatus {
  PENDING
  APPROVED
  REJECTED
}

enum PropertyStatus {
  DRAFT
  PENDING
  APPROVED
  REJECTED
}

model User {
  id                 String        @id @default(uuid())
  email              String        @unique
  fullName           String
  authProvider       AuthProvider
  providerId         String        @unique
  avatarUrl          String?
  role               UserRole      @default(INVESTOR)
  phone              String?
  timezone           String?
  preferredLanguage  String?       
  deletedAt          DateTime?
  createdAt          DateTime      @default(now())
  updatedAt          DateTime      @updatedAt

  investor Investor?
  client   Client?
  wallets  Wallet[]
  investments Investment[]
  kycRecord KycRecord?
  visits Visit[]
  notifications Notification[]
}

model Investor {
  id     String @id @default(uuid())
  userId String @unique
  user   User   @relation(fields: [userId], references: [id])

  nationality        String
  isVerified         Boolean   @default(false)
  verifiedAt         DateTime?
  verificationMethod String?
  dateOfBirth        DateTime?
  institutionName    String?
  vatNumber          String?
  phoneNumber        String?
  address            String?
  city               String?
  country            String?
  postalCode         String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  wallets     Wallet[]
}

model Wallet {
  id         String     @id @default(uuid())
  investorId String
  investor   Investor   @relation(fields: [investorId], references: [id])
  address    String     @unique
  blockchain Blockchain @default(SEPOLIA)
  isVerified Boolean    @default(false)
  verifiedAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  User        User?        @relation(fields: [userId], references: [id])
  userId      String?
}

model Property {
  id                     String   @id @default(cuid())
  clientId               String
  client                 Client   @relation(fields: [clientId], references: [id], onDelete: Cascade)
  title                  String
  description            String
  country                String
  city                   String
  address                String
  imageUrls              String[] @default([])
  totalPrice             Decimal
  tokenPrice             Decimal
  irr                    Decimal
  apr                    Decimal
  valueGrowth            Decimal
  minInvestment          Decimal
  tokensAvailablePercent Decimal
  tokenSymbol            String   @unique
  status                 PropertyStatus @default(DRAFT)
  isFeatured             Boolean  @default(false)
  createdAt              DateTime @default(now())
  updatedAt              DateTime @updatedAt
  token                  Token?
  investments            Investment[]
  visits                 Visit[]
}

model Token {
  id              String   @id @default(cuid())
  propertyId      String   @unique
  property        Property @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  name            String
  symbol          String   @unique
  decimals        Int
  totalSupply     Decimal
  contractAddress String   @unique
  chainId         String
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  investments     Investment[]
}

model Investment {
  id            String   @id @default(cuid())
  investorId    String
  tokenId       String
  propertyId    String
  amount        Decimal
  tokensBought  Decimal
  status        String
  txHash        String? @unique
  walletAddress String
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  investor      User     @relation(fields: [investorId], references: [id])
  token         Token    @relation(fields: [tokenId], references: [id])
  property      Property @relation(fields: [propertyId], references: [id])
}

model Client {
  id          String   @id @default(uuid())
  userId      String   @unique
  user        User     @relation(fields: [userId], references: [id])
  companyName String
  status      ClientStatus @default(PENDING)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  properties  Property[]
}

model KycRecord {
  id             String   @id @default(cuid())
  userId         String   @unique
  status         String   @default("PENDING") // PENDING | VERIFIED | REJECTED
  documentType   String?
  country        String?
  provider       String?  // The KYC provider used (e.g., "sumsub", "veriff")
  referenceId    String?  // External reference ID from the provider
  providerData   Json?    // Raw provider data for audit/debugging
  verifiedAt     DateTime?
  rejectedAt     DateTime?
  rejectionReason String?
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Visit {
  id          String   @id @default(cuid())
  propertyId  String
  userId      String?  // optional if anonymous
  ipAddress   String?
  userAgent   String?
  referrer    String?
  createdAt   DateTime @default(now())

  property    Property @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  user        User?    @relation(fields: [userId], references: [id])
}

model Notification {
  id         String   @id @default(cuid())
  userId     String
  type       String
  title      String
  message    String
  isRead     Boolean  @default(false)
  createdAt  DateTime @default(now())
  readAt     DateTime?

  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}
